<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter id="events" xmlns:xi="http://www.w3.org/2003/XInclude">
  <title>Events</title>

  <epigraph>
    <attribution>The Tenth Doctor (David Tennant)</attribution>
    <para>Crossing into established events is strictly forbidden. Except for
    cheap tricks.</para>
  </epigraph>

  <section id="events-introduction">
    <title>Introduction</title>
    <para>Once you have set up a scene on the stage, in order to respond
    to user interaction you will have to handle events coming from the
    underlying platform. Events are relayed to actors by Clutter in form
    of Vala signals.</para>

    <para>There are various events that Clutter will handle: mostly, they
    deal with input devices, like a mouse pointer or a keyboard; but they can
    also come from the windowing system, like the
    <emphasis>delete-event</emphasis> signal that is emitted when the user
    closes the window of the stage.</para>

    <para>Each event has a particular <emphasis>source</emphasis>, that is
    the actor that received the event. The event handling sequence is divided
    in two phases:</para>

    <orderedlist>
      <listitem><para>the <emphasis>capture</emphasis> phase, which consists
      in an emission of the <emphasis>captured-event</emphasis> signal
      starting from the stage to, following the parent-child relationship,
      the source of the event;</para></listitem>
      <listitem><para>the <emphasis>bubble</emphasis> phase, which consists
      in an emission of the <emphasis>event</emphasis> signal starting from
      the source of the event to, following the parent-child
      relationship, the stage.</para></listitem>
    </orderedlist>

    <para>At any point during the event emission sequence a handler of either
    the captured-event or the event signals can stop it, by returning a boolean
    value of <emphasis>true</emphasis>, which means that the event has been
    handled. If an event hasn't  been handled, a boolean value of
    <emphasis>false</emphasis> should be returned instead.</para>
  </section>

  <section id="events-handling-key-events">
    <title>Handling key events</title>

    <section>
      <title>Problem</title>
      <para>You want to respond to key presses on an actor.</para>
    </section>

    <section>
      <title>Solutions</title>

      <para>There are two possible solutions:</para>

      <orderedlist>
        <listitem>
          <para><emphasis>Solution 1:</emphasis> Connect a callback to the
          actor; inside the callback, manually analyse which key and
          modifier(s) were pressed and react accordingly.</para>
        </listitem>
        <listitem>
          <para><emphasis>Solution 2:</emphasis> Use an actor's
          <type>BindingPool</type> to declaratively assign
          actions to specific key and modifier combinations.</para>
        </listitem>
      </orderedlist>

      <para>Each solution is covered below.</para>

      <section>
        <title>Solution 1</title>

        <para>Connect the <emphasis>key-press-event</emphasis>
        signal for an actor to a callback; then examine the event
        in the callback to determine which key and modifiers were
        pressed.</para>

        <para>First, connect an actor's
        <emphasis>key-press-event</emphasis> signal to a callback:</para>

        <informalexample>
          <programlisting>
actor.key_press_event.connect(key_press_cb);
          </programlisting>
        </informalexample>

        <para>Then, in the callback, check which key was pressed and which
        modifiers were down at the same time. For example, this callback
        checks for a press on the up arrow key and whether
        the <keycap>Shift</keycap> and/or <keycap>Ctrl</keycap>
        key were down:</para>

        <informalexample>
          <programlisting>
<![CDATA[
bool
key_press_cb(Actor source,
             Event event) {
  int keyval = event.get_key_symbol();

  ModifierType state = event.get_state();
  bool shift_pressed = (state & ModifierType.SHIFT_MASK ? true : false);
  bool ctrl_pressed = (state & ModifierType.CONTROL_MASK ? true : false);

  if (keyval == Key.Up) {
    if (shift_pressed & ctrl_pressed)
      stdout.printf("Up and shift and control pressed\n");
    else if (shift_pressed)
      stdout.printf("Up and shift pressed\n");
    else
      stdout.printf("Up pressed\n");

      /* The event was handled, and the emission should stop */
    return true;
  }

  /* The event was not handled, and the emission should continue */
  return false;
}
]]>
          </programlisting>
        </informalexample>

        <note>
          <para>Clutter provides a range of key value definitions
          (like <constant>Key.Up</constant>, used above). These are
          generated from the list in the
          <ulink url="http://cgit.freedesktop.org/xorg/proto/x11proto/plain/keysymdef.h">X.Org source code</ulink>
          (replace "XK" with "Key." in the definitions there to get the
          Clutter equivalents). Alternatively, look at the
          <ulink url="http://www.valadoc.org/#!api=clutter-1.0/Clutter.Key">
            online list
          </ulink>.</para>

          <para><constant>ModifierType.SHIFT_MASK</constant>,
          <constant>ModifierType.CONTROL_MASK</constant>, and other modifiers are
          defined in the <type>ModifierType</type> enum.</para>
        </note>

      </section>

      <section>
        <title>Solution 2</title>

        <para>Assign actions to an actor's <type>BindingPool</type>.
        A binding pool stores mappings from a key press (either a single key
        or a key plus modifiers) to actions; an action is simply a callback
        function with a specific signature.</para>

        <para>While this approach is trickier to implement, it is more
        flexible and removes the drudgery of writing branching code to
        handle different key presses. See the
        <link linkend="events-handling-key-events-discussion">Discussion</link>
        section for more details.</para>

        <para>To use this approach with an actor which will receive key press
        events, first get that actor's binding pool. In the example below,
        we're using the binding pool for the default
        <type>Stage</type>:</para>

        <informalexample>
          <programlisting>
BindingPool binding_pool = BindingPool.get_for_class(Stage);
          </programlisting>
        </informalexample>

        <para>Next, install actions into the binding pool. For example, to
        install an action bound to the up arrow key, which calls the
        <function>move_up()</function> method when that key is pressed,
        you would do:</para>

        <informalexample>
          <programlisting>
binding_pool.install_action("move-up",    /* identifier */
                            Key.Up,       /* up arrow pressed */
                            0,            /* no modifiers pressed */
                            move_up);
          </programlisting>
        </informalexample>

        <para>Another example, binding up arrow +
        <keycap>Shift</keycap> + <keycap>Ctrl</keycap> to an action
        which calls <function>move_up_shift_control()</function> when
        activated:</para>

        <informalexample>
          <programlisting>
binding_pool.install_action("move-up-shift-control",
                            Key.Up,
                            ModifierType.SHIFT_MASK + ModifierType.CONTROL_MASK,
                            move_up_shift_control);
          </programlisting>
        </informalexample>

        <para>The method called when an action is activated looks
        like this (for <function>move_up()</function>):</para>

        <informalexample>
          <programlisting>
void
move_up(Actor instance,
        string action_name,
        int key_val,
        ModifierType modifiers) {
  
  stdout.printf("Up pressed\n");
}
          </programlisting>
        </informalexample>

        <para>Then bind the <emphasis>key-press-event</emphasis> signal
        for the actor (in our case, the stage) to a callback:</para>

        <informalexample>
          <programlisting>
Stage.get_default().key_press_event.connect(key_press_cb);
          </programlisting>
        </informalexample>

        <para>Finally, inside the callback, pass control to the actor's
        binding pool rather than dissecting the key press event
        yourself:</para>

        <informalexample>
          <programlisting>
bool
key_press_cb(Actor actor,
             Event event) {
  
  BindingPool pool = BindingPool.find(actor.get_type().name());

  return pool.activate(event.get_key_symbol(), event.get_state(), actor);
}
          </programlisting>
        </informalexample>

        <para>Now, when a key + modifiers that have been bound to an action
        are pressed on the actor, the appropriate action is activated.</para>

      </section>
    </section>

    <section id="events-handling-key-events-discussion">
      <title>Discussion</title>

      <section>
        <title>Pros and cons of Solution 1 and Solution 2</title>

        <para>Solution 1 is the simplest (in terms of the amount of code you
        have to write for simple cases), but could quickly turn into a mess if
        you need many conditions or want to capture many key combinations.
        Also, if multiple actors need to respond to key press events, you'll
        need similar event dissection code in each callback.</para>

        <para>Solution 2 is more complicated to implement, but scales better
        if you have many different key combinations on multiple actors.
        The binding pool protects you from the minutiae of detecting which
        keys were pressed, leaving you to concentrate on the
        triggered actions instead. This could simplify your control
        logic.</para>

        <para>In addition, Solution 2 lets you write a single callback to
        handle all key press events for all actors. This callback could then
        use <function>BindingPool.find()</function>
        (as in the example code) to determine which binding pool to
        activate (depending on which actor received the key press
        event).</para>

        <para>Finally, a binding pool allows you to block and unblock actions.
        This means you can make the response to a key press event conditional
        on application state. For example, let's say you wanted the up arrow
        key to move an actor, but only when the actor is at the bottom
        of the stage. To implement this, you could disable the up arrow key
        action in the binding pool initially; then, once the actor reaches the
        bottom of the stage, enable the up arrow key action again. While this
        is possible with Solution 1, you would have to implement more of the
        state management code yourself.</para>
      </section>

      <section>
        <title>Other useful things to know about key press events</title>

        <itemizedlist>
          <listitem>
            <para>A <type>KeyEvent</type> contains only a
            <emphasis>single</emphasis> key value, plus possibly one
            or more modifier keys (like <keycap>Shift</keycap>,
            <keycap>Ctrl</keycap>, <keycap>Alt</keycap> etc.).
            There are no functions in the Clutter API which return
            events for tracking near-simultaneous presses on multiple
            keys.</para>
          </listitem>

          <listitem>
            <para>By default, the stage receives all key events.
            To make another actor receive key events, use
            <function>Stage.set_key_focus()</function>:</para>

            <informalexample>
              <programlisting>
/*
 * stage is a Stage instance;
 * actor is the Actor instance which should receive key events
 */
stage.set_key_focus(actor);
              </programlisting>
            </informalexample>
          </listitem>
        </itemizedlist>

      </section>

    </section>

  </section>

  <section id="events-mouse-scroll">
    <title>Detecting mouse scrolling on an actor</title>

    <section>
      <title>Problem</title>

      <para>You want to detect when the mouse is scrolled on an
      actor (e.g. the pointer is over an actor when a mouse
      wheel is scrolled).</para>
    </section>

    <section>
      <title>Solution</title>

      <para>Connect a callback handler to the <code>scroll-event</code>
      signal of an actor.</para>

      <para>First, ensure that the actor is reactive (i.e. will
      respond to events):</para>

      <informalexample>
        <programlisting>
<![CDATA[
actor.reactive = true;
]]>
        </programlisting>
      </informalexample>

      <para>Next, create a callback handler to examine the scroll
      event and respond to it:</para>

      <informalexample>
        <programlisting>
<![CDATA[
bool
scroll_event_cb(Actor actor,
                ScrollEvent event) {  
  /* replace these stubs with real code to move the actor etc. */
  switch (event.direction) {
  case ScrollDirection.UP:
    stdout.printf("Scrolled up\n");
    break;
  case ScrollDirection.DOWN:
    stdout.printf("Scrolled down\n");
    break;
  case ScrollDirection.RIGHT:
    stdout.printf("Scrolled right\n");
    break;
  case ScrollDirection.LEFT:
    stdout.printf("Scrolled left\n");
    break;
  }

  return true; /* event has been handled */
}
]]>
        </programlisting>
      </informalexample>

      <para>Finally, connect the callback handler to the
      <code>scroll-event</code> signal of the actor:</para>

      <informalexample>
        <programlisting>
<![CDATA[
actor.scroll_event.connect(scroll_event_cb);
]]>
        </programlisting>
      </informalexample>

    </section>

    <section>
      <title>Discussion</title>

      <para>A standard mouse wheel will only return up and
      down movements; but in cases where the mouse has left and
      right scrolling (e.g. a trackball mouse or trackpad), left and
      right scroll events may also be emitted.</para>

      <section>
        <title>Creating a scrolling viewport for an actor</title>

        <para>While the simple outline above explains the basics
        of how to connect to scroll events, it doesn't do much to
        help with <emphasis>really</emphasis> implementing scrolling
        over an actor. That's what we'll do in this section.</para>

        <note>
          <para>The full code for the example we'll walk through here is
          available in <link linkend="events-mouse-scroll-example">this later
          section</link>.</para>
        </note>

        <para>Scrolling over an actor actually requires coordination
        between two components:</para>

        <orderedlist>
          <listitem>
            <formalpara>
              <title>Scrollable actor</title>
              <para>An actor which is too large to fit on the stage
              or inside the area of the UI assigned to it (otherwise
              there's no need to scroll over it...).</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title>Viewport</title>
              <para>This displays a cropped view of part of the scrollable
              actor, revealing different parts of it as scroll events
              occur.</para>
            </formalpara>
          </listitem>
        </orderedlist>

        <para>Here are the steps required to set up the two actors:</para>

        <orderedlist>
          <listitem>
            <para>Create the scrollable actor; it should be larger
            than the viewport. This example uses a <type>Texture</type>,
            but any <type>Actor</type> will work:</para>
            <informalexample>
              <programlisting>
/* get image file path, set up stage etc. */

Texture texture = new Texture();
texture.keep_aspect_ratio = true;

/*
 * set the texture's height so it's as tall as the stage
 * (STAGE_HEIGHT is define'd at the top of the file)
 */
texture.request_mode = RequestMode.WIDTH_FOR_HEIGHT;
actor.height = STAGE_HEIGHT;

/*
 * load the image file;
 * see <link linkend="textures-aspect-ratio">this recipe</link> for more about loading images into textures
 */
texture.set_from_file(image_file_path);
              </programlisting>
            </informalexample>
          </listitem>

          <listitem>

            <para>Create the viewport. The simplest way to do
            this is with a <type>Group</type>:</para>

            <informalexample>
              <programlisting>
<![CDATA[
Group viewport = new Group();

/* viewport is _shorter_ than the stage (and the texture) */
viewport.width = STAGE_WIDTH;
viewport.height = STAGE_HEIGHT * 0.5;

/* align the viewport to the center of the stage's y axis */
viewport.add_constraint(AlignConstraint(stage, AlignAxis.Y_AXIS, 0.5));

/* viewport needs to respond to scroll events */
viewport.reactive = true;

/* clip all actors inside the viewport to that group's allocation */
viewport.clip_to_allocation = true;
]]>
                </programlisting>
              </informalexample>

              <para>The key here is setting
              <code>viewport.clip_to_allocation = true;</code>.
              This configures the <varname>viewport</varname> group so
              that any of its children are clipped: i.e. only parts of
              its children which fit inside its allocation are visible. This
              in turn requires setting an explicit size on the group,
              rather than allowing it to size itself to fit its
              children (the latter is the default).</para>

          </listitem>

          <listitem>
            <para>Put the scrollable actor into the viewport; and
            the viewport into its container (in this case,
            the default stage):</para>

            <informalexample>
              <programlisting>
viewport.add_child(texture);
stage.add_child(viewport);
              </programlisting>
            </informalexample>

          </listitem>

          <listitem>
            <para>Create a callback handler for <code>scroll-event</code>
            signals emitted by the viewport:</para>

            <informalexample>
              <programlisting>
<![CDATA[
bool
scroll_event_cb(Actor viewport,
                Actor scrollable,
                ScrollEvent event) {
  /* no need to scroll if the scrollable is shorter than the viewport */
  if (scrollable.height < viewport.height)
    return true;
  
  float y = scrollable.y;
  
  switch (event.direction) {
  case ScrollDirection.UP:
    y += SCROLL_AMOUNT;
    break;
  case ScrollDirection.DOWN:
    y -= SCROLL_AMOUNT;
    break;
  case ScrollDirection.LEFT:
  case ScrollDirection.RIGHT:
    return true;
  }
  
  scrollable.animate(AnimationMode.EASE_OUT_CUBIC,
                     300,
                     "y",
                     y.clamp(viewport.height - scrollable.height, 0));
  
  return true;
}
]]>
              </programlisting>
            </informalexample>

            <para>The approach taken here is to move the scrollable
            actor up, relative to the viewport. Initially, the
            scrollable will have a <code>y</code> coordinate value
            of <code>0.0</code> (aligned to the top of the viewport).
            Scrolling down decrements the
            <code>y</code> coordinate (down to a minumum of
            <code>viewport_height - scrollable_height</code>). This moves
            the top of the scrollable actor "outside" the clip area of the
            viewport; simultaneously, more of the bottom part of the
            scrollable moves into the clip area, becoming visible.</para>

            <para>Scrolling up increments the <code>y</code> coordinate
            (but only up to a maximum value of <code>0.0</code>).</para>

            <para>To see how this works in practice, look at
            <link linkend="events-mouse-scroll-example">the code
            sample</link>. There, the height of the scrollable actor is
            set to <code>300</code> and the height of the viewport to
            <code>150</code>. This means that the <code>y</code>
            coordinate value for the scrollable actor will vary between
            <code>0.0</code>, where its top is visible and its base
            clipped,</para> and <code>-150</code> where its base is
            visible and its top is clipped (<code>-150</code> is
            <code>150</code> (the viewport's height) minus
            <code>300</code> (the scrollable's height)).
          </listitem>

          <listitem>
            <para>Connect the callback handler to the signal; note
            that we pass the scrollable actor (the texture) to the callback,
            as we're moving the texture relative to the viewport to
            create the scrolling effect:</para>

            <informalexample>
              <programlisting>
viewport.scroll_event.connect((viewport, event) => scroll_event_cb(viewport, scrollable, event));
              </programlisting>
            </informalexample>
          </listitem>

        </orderedlist>

        <para>Here's a video of the result:</para>

        <inlinemediaobject>
          <videoobject>
            <videodata fileref="videos/events-mouse-scroll.ogv"/>
          </videoobject>
          <alt>
            <para>Video showing a scrollable actor</para>
          </alt>
        </inlinemediaobject>

      </section>
    </section>

    <section>
      <title>Full example</title>

      <example id="events-mouse-scroll-example">
        <title>Mouse scrolling over a <type>ClutterActor</type></title>
        <programlisting>
<xi:include href="examples/events-mouse-scroll.vala" parse="text">
  <xi:fallback>a code sample should be here... but isn't</xi:fallback>
</xi:include>
        </programlisting>
      </example>
    </section>

  </section>

  <section id="events-pointer-motion">
    <title>Detecting pointer movements on an actor</title>

    <section id="events-pointer-motion-problem">
      <title>Problem</title>

      <para>You want to be able to tell when the pointer (e.g. associated
      with a mouse or touches on a screen) enters, leaves, or moves over
      an actor.</para>

      <para>Example use cases include:</para>

      <itemizedlist>
        <listitem>
          <para>Adding a tooltip or hover effect to an actor when
          a pointer moves onto it.</para>
        </listitem>
        <listitem>
          <para>Tracing the path of the pointer over an actor (e.g.
          in a drawing application).</para>
        </listitem>
      </itemizedlist>

    </section>

    <section id="events-pointer-motion-solution">
      <title>Solution</title>

      <para>Connect to the pointer motion signals emitted by the actor.</para>

      <section>
        <title>Responding to crossing events</title>

        <para>To detect the pointer crossing the boundary of an actor
        (entering or leaving), connect to the <code>enter-event</code>
        and/or <code>leave-event</code> signals. For example:</para>

        <informalexample>
          <programlisting>
var actor = new Texture();

/* ...set size, color, image etc., depending on the actor... */

/* make the actor reactive: see <link linkend="events-pointer-motion-discussion">Discussion</link> for more details */
actor.reactive = true;

/* connect to the signals */
actor.enter_event.connect(pointer_enter_cb);
actor.leave_event.connect(leave_event_cb);
          </programlisting>
        </informalexample>

        <para>The signature for callbacks connected to each of these
        signals is:</para>

        <informalexample>
          <programlisting>
bool
on_crossing(Actor source, Event event);
          </programlisting>
        </informalexample>

        <para>In the callback, you can examine the event to get the
        coordinates where the pointer entered or left the actor. For
        example, <function>pointer_enter_cb()</function> could
        follow this template:</para>

        <informalexample id="events-pointer-motion-callback-example">
          <programlisting>
<![CDATA[
/* the event passed to the callback is of type CrossingEvent */
bool
pointer_enter_cb(Actor actor,
                 CrossingEvent event) {
  /*
   * as the coordinates are relative to the stage, rather than
   * the actor which emitted the signal, it can be useful to
   * transform them to actor-relative coordinates
   */
  float x, y;
  actor.transform_stage_points(event.x, event.y, out x, out y);
  stdout.printf("pointer at stage x %.0f, y %.0f; actor x %.0f, y %.0f",
                event.x, event.y,
                x, y);
  
  return true;
}
]]>
          </programlisting>
        </informalexample>

        <para>See <link linkend="events-pointer-motion-example-1">the
        code example in the appendix</link> for an example of how
        you can implement a hover effect on a "button" (rectangle
        with text overlay) using this approach.</para>

      </section>

      <section>
        <title>Responding to motion events</title>

        <para>Motion events occur when a pointer moves over an actor;
        the actor emits a <code>motion-event</code> signal when this
        happens. To respond to motion events, connect to this signal:</para>

        <informalexample>
          <programlisting>
/* set up the actor, make reactive etc., as above */

/* connect to motion-event signal */
actor.motion_event.connect(pointer_motion_callback);
          </programlisting>
        </informalexample>

        <para>The signature of the callback is the same as for
        the <code>enter-event/leave-event</code> signals, so you can use
        <link linkend="events-pointer-motion-callback-example">code
        similar to the above</link> to handle it. However, the
        type of the event is a <type>MotionEvent</type>
        (rather than a <type>CrossingEvent</type>).</para>

      </section>

    </section>

    <section id="events-pointer-motion-discussion">
      <title>Discussion</title>

      <para>A few more useful things to know about pointer motion
      events:</para>

      <itemizedlist>

        <listitem>
          <para>Each crossing event is accompanied by a motion event at
          the same coordinates.</para>
        </listitem>

        <listitem>
          <para>Before an actor will emit signals for pointer events,
          it needs to be made reactive with:</para>

          <informalexample>
            <programlisting>
actor.reactive = true;
            </programlisting>
          </informalexample>
        </listitem>

        <listitem>
          <para>A pointer event structure includes other data. Some
          examples:</para>

          <informalexample>
            <programlisting>
/* keys and mouse buttons pressed down when the pointer moved */
event.modifier_state;

/* time (since the epoch) when the event occurred */
event.time;

/* actor where the event originated */
event.source;

/* stage where the event originated */
event.stage;
            </programlisting>
          </informalexample>
        </listitem>

        <listitem>
          <para>The coordinates of an event (as returned by
          <code>event.x</code> and <code>event.y</code>) are relative
          to the stage where they originated, rather than the actor. Unless
          the actor is the same size as the stage, you'll typically want
          the actor-relative coordinates instead. To get those, use
          <function>Actor.transform_stage_point()</function>.</para>
        </listitem>

      </itemizedlist>

      <para>The <link linkend="events-pointer-motion-example-4">simple
      scribble application</link> gives a more
      thorough example of how to integrate pointer events into a
      Clutter application (in this case, for drawing on a
      <type>Texture</type>).</para>

      <para>The effect of actor depth on pointer motion events is
      worth slightly deeper discussion, and is covered next.</para>

      <section>
        <title>Pointer events on actors at different depths</title>

        <para>If you have actors stacked on top of each other, the
        reactive actor nearest the "top" is the one
        which emits the signal (when the pointer crosses into or moves
        over it). "Top" here means either at the top of
        the depth ordering (if all actors are at the same depth)
        or the closest to the view point (if actors have different
        depths in the <code>z</code> axis).</para>

        <para>Here's an example of three rectangles overlapping each
        other:</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata format="PNG"
                         fileref="images/events-pointer-motion-stacking.png" />
            </imageobject>
            <alt>
              <para>Pointer events in actors with different depth ordering</para>
            </alt>
          </mediaobject>
        </screenshot>

        <para>The rectangles are all at the same point on the
        <code>z</code> axis but stacked (different positions in the depth
        order). They have the following properties:</para>

        <itemizedlist>
          <listitem>
            <para>The <emphasis>red</emphasis> rectangle is lowest down
            the depth ordering and reactive. Pointer motion signals are
            emitted by this actor when the pointer crosses or moves on the
            area of the rectangle <emphasis>not</emphasis> overlapped by the
            green rectangle.</para>
          </listitem>
          <listitem>
            <para>The <emphasis>green</emphasis> rectangle is in the
            middle of the depth ordering and reactive. This actor emits
            events over its whole surface, even though it is overlapped
            by the blue rectangle (as the blue rectangle is not
            reactive).</para>
            <para>Even if the blue rectangle were fully opaque, a pointer
            crossing into or moving on the green rectangle's area (even if
            obscured by the blue rectangle) would still cause a signal
            to be emitted.</para>
          </listitem>
          <listitem>
            <para>The <emphasis>blue</emphasis> rectangle is at the top
            of the depth ordering and <emphasis>not</emphasis> reactive.
            This actor doesn't emit any pointer motion signals and doesn't
            block events from occurring on any other actor.</para>
          </listitem>
        </itemizedlist>

        <para>See <link linkend="events-pointer-motion-example-3">the
        sample code in the appendix</link> for more details.</para>

      </section>

    </section>

    <section>
      <title>Full examples</title>

      <example id="events-pointer-motion-example-1">
        <title>Simple button with a hover animation (change in opacity
        as the pointer enters and leaves it)</title>
        <programlisting>
<xi:include href="examples/events-pointer-motion-crossing.vala" parse="text">
  <xi:fallback>a code sample should be here... but isn't</xi:fallback>
</xi:include>
        </programlisting>
      </example>

      <example id="events-pointer-motion-example-2">
        <title>Detecting pointer motion on a <type>ClutterRectangle</type></title>
        <programlisting>
<xi:include href="examples/events-pointer-motion.vala" parse="text">
  <xi:fallback>a code sample should be here... but isn't</xi:fallback>
</xi:include>
        </programlisting>
      </example>

      <example id="events-pointer-motion-example-3">
        <title>How actors influence pointer events on each other</title>
        <programlisting>
<xi:include href="examples/events-pointer-motion-stacked.vala" parse="text">
  <xi:fallback>a code sample should be here... but isn't</xi:fallback>
</xi:include>
        </programlisting>
      </example>

      <example id="events-pointer-motion-example-4">
        <title>Scribbling on a <type>ClutterTexture</type> in response
        to pointer events</title>
        <programlisting>
<xi:include href="examples/events-pointer-motion-scribbler.vala" parse="text">
  <xi:fallback>a code sample should be here... but isn't</xi:fallback>
</xi:include>
        </programlisting>
      </example>

    </section>

  </section>

  <section id="events-buttons">
    <title>Making an actor respond to button events</title>

    <section>
      <title>Problem</title>

      <para>You want an actor to respond to button events. These might
      be buttons on an input device like a mouse;
      or input events caused by other means, like touches on a screen.</para>

      <para>Some examples of where this is useful:</para>

      <itemizedlist>
        <listitem>
          <para>For implementing button widgets which respond to
          button clicks.</para>
        </listitem>
        <listitem>
          <para>To make actor selections by mouse click (e.g.
          as part of a drawing application).</para>
        </listitem>
        <listitem>
          <para>To recognise a button press followed by pointer
          motion and button release (e.g. to implement drag
          and drop or kinetic animations).</para>
        </listitem>
      </itemizedlist>

    </section>

    <section>
      <title>Solution</title>

      <para>Connect a handler to the <emphasis>button-press-event</emphasis>
      and/or <emphasis>button-release-event</emphasis> signals of an
      actor.</para>

      <note>
        <para>The <emphasis>button-press-event</emphasis> is emitted
        when a button is pressed (not necessarily released) on a reactive
        actor; the <emphasis>button-release-event</emphasis> when a
        button is released on a reactive actor (even if the button was
        pressed down somewhere else).</para>
      </note>

      <para>First, ensure the actor is reactive:</para>

      <informalexample>
        <programlisting>
actor.reactive = true;
        </programlisting>
      </informalexample>

      <para>Next, create a method (or delegate) to handle the signal(s) you are
      interested in. The method/delegate signature is the same for both the
      press and release signals:</para>

      <informalexample>
        <programlisting>
bool
callback_method(Actor actor, ButtonEvent event);
        </programlisting>
      </informalexample>

      <para>You can use a single function as the
      callback for both signals (or write a different one for each signal).
      Here's an example function which can be used as a callback
      for both press and release signals, as it simply pulls data
      out of the event and displays it:</para>

      <informalexample>
        <programlisting>
/*
 * <varname>event</varname> is a <type>ButtonEvent</type>
 * for both the press and the release signal; it contains
 * data about where the event occurred
 */
bool
button_event_cb (Actor actor, ButtonEvent event)
{
  /*
   * <varname>event.button</varname> indicates which button
   * triggered the event (e.g. 1 for the primary
   * button)
   *
   * <varname>event.type</varname> indicates the type of event;
   * it will be one of EventType.BUTTON_PRESSED
   * and EventType.BUTTON_RELEASED
   *
   * <varname>event.x</varname> and <varname>event.y</varname> indicate
   * where the pointer was (relative to the stage)
   *
   * <varname>event.button</varname> indicates which button
   * triggered the event
   *
   * <varname>event.modifier_state</varname> indicates which keys were down
   * when the event occurred; it is a bitmask
   * of values from the <type>ModifierType</type> enum
   *
   * <varname>event.click_count</varname> indicates how many
   * times the button was clicked (i.e. 1 for
   * a single-click and 2 for a double-click)
   */

  string event_type = "pressed";
  if (event.type == EventType.BUTTON_RELEASE)
    event_type = "released";

  string ctrl_pressed = "ctrl not pressed";
  if ((event.modifier_state &amp; ModifierType.CONTROL_MASK &gt; 0)
    ctrl_pressed = "ctrl pressed";

  stderr.printf("button %d was %s at %.0f,%.0f; %s; click count %d",
                event.button,
                event_type,
                event.x,
                event.y,
                ctrl_pressed,
                event.click_count);

  return true;
}
        </programlisting>
      </informalexample>

      <para>Finally, connect the signals to the function(s):</para>

      <informalexample>
        <programlisting>
/* connect the press event */
actor.button_press_event.connect(button_event_cb);

/* connect the release event */
actor.button_release_event.connect(button_event_cb);
        </programlisting>
      </informalexample>

      <para>Pressing or releasing a button on the actor will now
      trigger a call to the <function>button_event_cb()</function>
      method. See <link linkend="events-buttons-example-1">the full
      example</link> for more details.</para>

    </section>

    <section>
      <title>Discussion</title>
      
      <para>Covered below is another way to handle a button press
      followed by a release on a single actor: by adding
      a <type>ClutterClickAction</type> to an actor. See
      <link linkend="events-buttons-clutterclickaction">this section</link>
      for details.</para>

      <para>Also, a <link linkend="events-buttons-example-3">longer
      example</link> is included, showing how to make use of button press,
      button release and pointer events in a simple drawing application.</para>

      <section>
        <title>Click count</title>

        <para>The click count records the number of times a press/release
        pair occurred in sequence; it is stored in
        <varname>event.click_count</varname>.</para>

        <note>
          <para>A press/release pair is effectively a click, so this term
          will be used from now on throughout this section,
          to make the explanation simpler. However, the click count has
          nothing to do with <type>ClickAction</type>s, described
          <link linkend="events-buttons-clutterclickaction">later</link>.
          </para>
        </note>

        <para>For clicks to be considered part of the same sequence (for
        the purposes of counting), all the clicks after the first one
        must occur within <varname>Settings.double_click_distance</varname>
        (pixels) of the first click; and the time between click
        <code>n</code> and click <code>n+1</code> must be <code>&lt;=</code>
        <varname>Settings.double_click_time</varname> (milliseconds).</para>

        <para>The clicks <emphasis>do not</emphasis> have to occur on
        the same actor: providing they occur within the double click
        distance and time, they are counted as part of the same click
        sequence. Also note that the clicks don't even have to happen
        on a reactive actor: providing they happen somewhere on the
        stage, they will still increment the click count.</para>

        <para>Reasonable defaults for the double click time and distance
        are stored in <type>Settings</type> when Clutter starts, but
        you can override these values.</para>
      </section>

      <section>
        <title>Button numbering</title>

        <para><varname>event.button</varname> is an integer
        representing the pressed or released button.</para>

        <para>In the case of a standard scroll mouse, the numbers
        returned are reliable across different hardware models:</para>

        <itemizedlist>
          <listitem>
            <para>1 = left mouse button in a right-handed configuration,
            or the right mouse button in a left-handed configuration</para>
          </listitem>
          <listitem>
            <para>2 = scroll wheel button</para>
          </listitem>
          <listitem>
            <para>3 = right mouse button in a right-handed configuration,
            or the left mouse button in a left-handed configuration</para>
          </listitem>
        </itemizedlist>

        <note><para>Clutter uses the same values as GDK for the 3 buttons
        above, so you can use the symbolic names provided by GDK:
        Gdk.BUTTON_PRIMARY, Gdk.BUTTON_MIDDLE, and
        Gdk.BUTTON_SECONDARY.</para></note>

        <para>For mice with more buttons, or other types of
        input devices, the mappings may not be so
        straightforward: you may have to experiment to see
        which button returns which value.</para>

      </section>

      <section id="events-buttons-clutterclickaction">
        <title><type>ClickAction</type>s</title>

        <para><type>Action</type>s add flexible event handling
        to <type>Actor</type>s. They recognise and abstract
        common sequences of low-level events into a single, more easily
        managed high-level event. In the case of a
        <type>ClickAction</type>, the abstraction is over
        a press followed by a release on a single actor. This is
        achieved by "synthesising" the press and release signals on
        the actor: in other words, the action captures those
        two signals when emitted by a single actor; and, once captured, the
        action emits a single <emphasis>clicked</emphasis> signal
        <emphasis>instead</emphasis> of the two signals being
        emitted by the actor.</para>

        <para>The pointer can move off the actor between the press and
        release, but the press and release must both occur on the same
        actor, with no intervening presses or releases on other
        actors. In addition, there are no maximum distance or time
        constraints on the press and release.</para>

        <para>If a press occurs and you want to force it to be released
        (e.g. to break a pointer grab after a certain length of
        time has elapsed), use
        <function>ClickAction.release()</function>.</para>

        <para>On the down side, the <emphasis>clicked</emphasis> signal
        doesn't present the same detailed <type>ButtonEvent</type>
        to the handler. So, for example, you can't get a click count from a
        <type>ClickAction</type> (though you could count
        the clicks yourself, of course); and you don't have access
        to the coordinates where the press or release occurred.</para>

        <para>To add a click action to a <type>Actor</type>:</para>

        <informalexample>
          <programlisting>
var action = new ClickAction();
actor.add_action(action);
          </programlisting>
        </informalexample>

        <note>
          <para>An actor must still be set to reactive so that its
          signals can be routed to a click action.</para>
        </note>

        <para>Create a handler function (note the function
        signature is different from the one for the press or
        release signal handler):</para>

        <informalexample>
          <programlisting>
void
clicked_cb (ClickAction action, Actor actor)
{
  // display the number of the clicked button
  stderr.printf("Button %d clicked", action.get_button());
}
          </programlisting>
        </informalexample>

        <para>Connect the signal to the handler:</para>

        <informalexample>
          <programlisting>
action.clicked.connect(clicked_cb);
          </programlisting>
        </informalexample>

        <para>The <link linkend="events-buttons-example-2">example
        code</link> gives a bit more detail about how to use click
        actions.</para>

      </section>

    </section>

    <section>
      <title>Full examples</title>

      <example id="events-buttons-example-1">
        <title>Examining properties of a <type>ButtonEvent</type></title>
        <programlisting>
<xi:include href="examples/events-buttons.vala" parse="text">
  <xi:fallback>a code sample should be here... but isn't</xi:fallback>
</xi:include>
        </programlisting>
      </example>

      <example id="events-buttons-example-2">
        <title>Using <type>ClickAction</type> to capture
        button events on an actor</title>
        <programlisting>
<xi:include href="examples/events-buttons-click.vala" parse="text">
  <xi:fallback>a code sample should be here... but isn't</xi:fallback>
</xi:include>
        </programlisting>
      </example>

      <example id="events-buttons-example-3">
        <title>Using button and pointer events for drawing</title>
        <para>This code was inspired by
        <ulink url="http://git.clutter-project.org/cluttersmith/">ClutterSmith</ulink>
        </para>
        <programlisting>
<xi:include href="examples/events-buttons-lasso.vala" parse="text">
  <xi:fallback>a code sample should be here... but isn't</xi:fallback>
</xi:include>
        </programlisting>
      </example>

    </section>

  </section>

</chapter>
